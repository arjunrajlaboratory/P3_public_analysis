##### UTILITIES FOR CELL ID RNAtag-SEQ ANALYSIS ##### 
# Contains functions used in initial analyses of RNAtag-seq from control and perturbation experiments
# Dependencies: tidyverse (load library before running sourced functions)

# simple read of count table generated by HTseq
# run once per sequencing run
# countFile - a filepath relative to your project folder
# Example usage:
# > setwd("~/Dropbox (RajLab)/Projects/cellid/")
# > countFile = "extractedData/RNAtagSeq/RNAtagTest1new/htseq_meltedData.tsv"
# > countData = loadRNAtagRun(countFile)
loadRNAtagRun <- function(countFile) {
  
  return(as_tibble(read.table(countFile, header = T)))
  
}


## calculate mapping statistics
# countData is a data frame of counts per gene_id as follows:
# Classes ‘tbl_df’, ‘tbl’ and 'data.frame' with variables:
# $ experiment: Factor - the name of each sequencing run
# $ sampleID  : Factor - the name of the pool in that sequencing run
# $ tagID     : Factor - the name of the RNAtag in that pool in that sequencing run
# $ gene_id   : Factor - the gene_id (Ensembl Gene ID) used in HTseq
# $ counts    : int    - the number of counts mapped to this gene_id in this sample
# 
# Returns mapList, a list with dataframe entries:
# $ 
unmappedRNAtagReadsPerSample <- function(countData) {
  
  mapList = list()
  
  # get un-mapped read stats
  unmappingDat <- countData %>%
    group_by(experiment, sampleID, tagID) %>%
    mutate(totalReads = sum(counts), combID = paste0(experiment, "_", sampleID, "_", tagID), fracRds = counts/totalReads) %>%
    filter(gene_id == "__alignment_not_unique" | gene_id == "__ambiguous" | gene_id == "__no_feature" | gene_id == "__not_aligned" | gene_id == "__too_low_aQual")
  
  unmappingDat2 <- unmappingDat %>%
    ungroup() %>%
    dplyr::select(combID, gene_id, fracRds) %>%
    spread(combID, fracRds)
  unmappingSum <- unmappingDat2 %>%
    dplyr::select(-gene_id) %>%
    summarise_all(funs(sum)) %>%
    gather("combID", "unmappedPerc", 1:(ncol(unmappingDat2)-1)) %>%
    mutate(mappedPerc = 1-unmappedPerc) %>%
    gather("readStatus", "percentage", unmappedPerc:mappedPerc) %>%
    separate(combID, into = c("experiment" ,"poolID", "tagID"), sep = "\\_")
  
  mapList[["unmappingDat"]] = unmappingDat2
  mapList[["unmappingSum"]] = unmappingSum
  
  return(mapList)
  
}

plotUnmapping <- function(unmappingSum){
  
  unmappedPlot <- ggplot(unmappingSum, aes(tagID, percentage)) +
    geom_bar(stat="identity", aes(fill = readStatus)) +
    facet_grid(poolID ~ .) +
    ggtitle("Percentage of reads Mapped vs Unmapped in each sample") +
    scale_fill_manual(values = c("mappedPerc" = "forestgreen", "unmappedPerc" = "red"))
  return(unmappedPlot)
  
}


## transcript abundance measures
# RPM: reads per million mapped reads
generateRPMfromCounts <- function(countData){
  
  # filter out unmapped reads
  countData = countData %>%
    filter(gene_id != "__alignment_not_unique" & gene_id != "__ambiguous" & gene_id != "__no_feature" & gene_id != "__not_aligned" & gene_id != "__too_low_aQual")
  
  rpms = countData %>%
    group_by(experiment, sampleID, tagID) %>%
    mutate(totalMappedReads = sum(counts), rpm = 1000000*counts/totalMappedReads) %>%
  
  return(rpms)
  
}

# RPKM: reads per kilobase per million mapped reads
generateRPKMfromCounts <- function(countData, geneIDlengths){
  
  # filter out unmapped reads
  countData = countData %>%
    filter(gene_id != "__alignment_not_unique" & gene_id != "__ambiguous" & gene_id != "__no_feature" & gene_id != "__not_aligned" & gene_id != "__too_low_aQual")
  
  # join with lengths per gene_id
  countData = inner_join(countData, geneIDlengths)
  
  rpkms = countData %>%
    group_by(experiment, sampleID, tagID) %>%
    mutate(totalMappedReads = sum(counts), rpm = 1000000*counts/totalMappedReads) %>%
    mutate(rpkm = 1000*rpm/length) %>%
    dplyr::select(-rpm)
  
  return(rpkms)
  
}

# TPM: transcripts per million mapped reads
generateTPMfromCounts <- function(countData, geneIDlengths){
  
  # filter out unmapped reads
  countData = countData %>%
    filter(gene_id != "__alignment_not_unique" & gene_id != "__ambiguous" & gene_id != "__no_feature" & gene_id != "__not_aligned" & gene_id != "__too_low_aQual")
  
  # join with lengths per gene_id
  countData = inner_join(countData, geneIDlengths)
  
  tpms = countData %>%
    group_by(experiment, sampleID, tagID) %>%
    mutate(rpk = 1000*counts/length, rpkScalePerMillion = sum(rpk)/1000000, tpm = rpk/rpkScalePerMillion) %>%
    dplyr::select(-c(rpk, rpkScalePerMillion))

  
  return(tpms)
  
}

generateTPMfromMappedCountsSE <- function(se){
  # CAUTION: Extremely large intermediate data format can exceed memory cap
  tpms <- SummarizedExperimentToTallTibble(se) %>%
    dplyr::select(combID, gene_id, TPM, length) %>% 
    dplyr::rename(counts = TPM) %>%
    separate(combID, into = c('experiment', 'sampleID', 'tagID'), sep = '\\_') %>%
    filter(gene_id != "__alignment_not_unique" & gene_id != "__ambiguous" & gene_id != "__no_feature" & gene_id != "__not_aligned" & gene_id != "__too_low_aQual") %>%
    group_by(experiment, sampleID, tagID) %>%
    mutate(rpk = 1000*counts/length, rpkScalePerMillion = sum(rpk)/1000000, tpm = rpk/rpkScalePerMillion) %>%
    dplyr::select(-c(rpk, rpkScalePerMillion))
  
  return(tpms)
  
}


makeSyntheticSample <- function(samps, name){
  
  colnames(samps) = c("gene_id", "s1", "s2")
  
  synth = samps %>%
    mutate(synthSamp = mean(s1,s2)) %>%
    dplyr::select(c(gene_id, synthSamp))
  colnames(synth) = c("gene_id", name)
  
  return(synth)
  
}


# Multiple plot function - from http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/, 2017/07/28
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


## Change quickly between a SummarizedExperiment object and a tidyverse tibble (tall format, all columns included from both sampleData and geneData)
SummarizedExperimentToTallTibble <- function(se){
  
  sampleData = as.data.frame(colData(se))
  sampleData$combID = rownames(sampleData)
  rownames(sampleData) = NULL
  
  geneData = as.data.frame(rowData(se)) #already includes gene_id column
  rownames(geneData) = NULL
  
  datWide = as.data.frame(assay(se))
  nSamp = dim(datWide)[2]
  
  datWide$gene_id = rownames(datWide)
  rownames(datWide) = NULL
  datTall = as_tibble(datWide) %>%
    gather(combID, TPM, 1:nSamp)
  
  
  datTall = left_join(datTall, as_tibble(sampleData), by = "combID") %>%
    left_join(as_tibble(geneData), by = "gene_id")
  
  return(datTall)
  
}

## perform unique DE gene check on a formatted results table from DESeq2
checkUniqueDESeq <- function(sigDEtbl, condOrder){
  
  # expects sigDEtbl columns: baseMean log2FoldChange      lfcSE        stat     pvalue      padj         gene_id    Product.Name   nDE
  # expects condOrder: complete order of unique Product.Name values
  allSoFar = sigDEtbl %>%
    filter(Product.Name == "blank")
  newTab = list()
  for (cond in condOrder) {
    
    tempAll = sigDEtbl %>%
      filter(Product.Name == cond)
    
    if(nrow(tempAll) > 0){
      nDE = unique(tempAll$nDE)
    } else {
      nDE = 0
    }
    
    newThisDrug = anti_join(tempAll, allSoFar, by = "gene_id") %>%
      group_by(Product.Name) %>%
      summarise(nNew = length(gene_id))
    if(nrow(newThisDrug) == 0) {
      newThisDrug = as_tibble(data.frame(
        Product.Name = cond,
        nNew = 0
      ))
    }
    newThisDrug$nDEthisDrug = nDE
    
    if(is.null(dim(newTab))){
      newTab = newThisDrug
    } else {
      newTab = bind_rows(newTab, newThisDrug)
    }
    
    allSoFar = bind_rows(allSoFar, tempAll)
    
  }
  
  newTab$totalNew = cumsum(newTab$nNew)
  
  newTab$order = 1:nrow(newTab)
  newTab$Product.Name = factor(newTab$Product.Name, levels = newTab$Product.Name[newTab$order])
  
  results = list(
    cumulativeUniqueDEgenes = newTab,
    orderedNonUniqueDEresultsTab = allSoFar
  )
  
  return(results)
  
}


## perform unique DE gene check on a formatted results table from DESeq2 - TFs only
checkUniqueDESeqTFs <- function(sigDEtbl, condOrder, tfTab){
  
  # expects sigDEtbl columns: baseMean log2FoldChange      lfcSE        stat     pvalue      padj         gene_id    Product.Name   nDE
  # expects condOrder: complete order of unique Product.Name values
  # expects tfTab columns: gene_id
  allSoFar = sigDEtbl %>%
    filter(Product.Name == "blank")
  
  sigDEtbl %<>%
    inner_join(tfTab, by = 'gene_id')
  
  newTab = list()
  for (cond in condOrder) {
    
    tempAll = sigDEtbl %>%
      filter(Product.Name == cond)
    
    if(nrow(tempAll) > 0){
      nDE = unique(tempAll$nDE)
    } else {
      nDE = 0
    }
    
    newThisDrug = anti_join(tempAll, allSoFar, by = "gene_id") %>%
      group_by(Product.Name) %>%
      summarise(nNew = length(gene_id))
    if(nrow(newThisDrug) == 0) {
      newThisDrug = as_tibble(data.frame(
        Product.Name = cond,
        nNew = 0
      ))
    }
    newThisDrug$nDEthisDrug = nDE
    
    if(is.null(dim(newTab))){
      newTab = newThisDrug
    } else {
      newTab = bind_rows(newTab, newThisDrug)
    }
    
    allSoFar = bind_rows(allSoFar, tempAll)
    
  }
  
  newTab$totalNew = cumsum(newTab$nNew)
  
  newTab$order = 1:nrow(newTab)
  newTab$Product.Name = factor(newTab$Product.Name, levels = newTab$Product.Name[newTab$order])
  
  results = list(
    cumulativeUniqueDEgenes = newTab,
    orderedNonUniqueDEresultsTab = allSoFar
  )
  
  return(results)
  
}


#### Main perturbability statistics utility function
### Returns: for each pair (cellType, gene_id): 
###     deltaKurtosis, deltaSkewness, deltaCV, deltaMaxMin, and deltaPP (for a given symmetric outer percentile)
###     tibble output also includes control mean expression values given as input.
### Accepts: 
### - tall_exp_tibble = a tibble with columns named c(condition, cellType, isControl, gene_id, RPM)
###         Can also include combID column.
###         If using TPM or other expression value, rename the column to RPM when using this function
### - mean_control_tibble = tibble of control mean expression values. Must contain at least cellType, gene_id columns.
###         This is a separate arg in order to have multiple expression unit measures of the mean.
### - extrFrac = outer percentile for deltaPP calculation. E.g., extrFrac = 0.05 checks 5%ile and 95%ile.
###         Default = 0.05

calculate_perturbability <- function(tall_exp_tibble, mean_control_tibble, extFrac = 0.05){
  
  rpmVarControlExtrema = tall_exp_tibble %>%
    filter(isControl == "control") %>%
    group_by(cellType, gene_id) %>%
    summarise(ctlLowerQ = as.numeric(quantile(RPM, probs = extFrac)[1]),
              ctlUpperQ = as.numeric(quantile(RPM, probs = (1-extFrac))[1]),
              ctlMax = max(RPM),
              ctlMin = min(RPM))
  
  variability_metrics_byControl = tall_exp_tibble %>%
    left_join(rpmVarControlExtrema, by = c("cellType", "gene_id")) %>%
    group_by(cellType, isControl, gene_id) %>%
    summarise(nSamp = length(RPM),
              meanRPM = mean(RPM),
              CV = sd(RPM)/mean(RPM),
              Var = var(RPM),
              fracExtreme = sum(RPM > ctlUpperQ | RPM < ctlLowerQ)/length(RPM),
              fracMaxMin = sum(RPM > ctlMax | RPM < ctlMin)/length(RPM),
              Kurtosis = kurtosis(RPM),
              Skewness = skewness(RPM))
  
  ## deltaCV(RPM)
  deltaCV = variability_metrics_byControl %>%
    dplyr::select(cellType, gene_id, isControl, CV) %>%
    group_by(cellType, gene_id) %>%
    spread(isControl, CV) %>%
    mutate(deltaCV = perturbed - control,
           controlCV = control,
           perturbedCV = perturbed) %>%
    dplyr::select(-c(control, perturbed))
  
  ## deltaKurtosis(RPM)
  deltaKurtosis = variability_metrics_byControl %>%
    dplyr::select(cellType, gene_id, isControl, Kurtosis) %>%
    group_by(cellType, gene_id) %>%
    spread(isControl, Kurtosis) %>%
    mutate(deltaKurtosis = perturbed - control,
           controlKurtosis = control,
           perturbedKurtosis = perturbed) %>%
    dplyr::select(-c(control, perturbed))
  
  ## deltaSkewness(RPM)
  deltaSkewness = variability_metrics_byControl %>%
    dplyr::select(cellType, gene_id, isControl, Skewness) %>%
    group_by(cellType, gene_id) %>%
    spread(isControl, Skewness) %>%
    mutate(deltaSkewness = perturbed - control,
           controlSkewness = control,
           perturbedSkewness = perturbed) %>%
    dplyr::select(-c(control, perturbed))
  
  ## extremal fraction of RPMs (deltaMM; outside control max and min)
  deltaMM = variability_metrics_byControl %>%
    dplyr::select(cellType, gene_id, isControl, fracMaxMin) %>% ungroup() %>%
    filter(isControl == "perturbed") %>%
    mutate(deltaMM = fracMaxMin) %>%
    dplyr::select(-c(isControl, fracMaxMin))
  
  ## near-extremal fraction of RPMs (deltaPP; outside control inner 90%ile range)
  deltaPPandMeans = variability_metrics_byControl %>%
    dplyr::select(cellType, gene_id, isControl, fracExtreme) %>%
    group_by(cellType, gene_id) %>%
    spread(isControl, fracExtreme) %>%
    mutate(deltaPP = perturbed - control) %>%
    dplyr::select(-c(control, perturbed)) %>%
    left_join(mean_control_tibble, by = c("cellType", "gene_id"))
  
  variability_metrics = deltaMM %>%
    left_join(deltaPPandMeans, by = c("cellType", "gene_id")) %>%
    left_join(deltaCV, by = c("cellType", "gene_id")) %>%
    left_join(deltaKurtosis, by = c("cellType", "gene_id")) %>%
    left_join(deltaSkewness, by = c("cellType", "gene_id"))
  
  return(variability_metrics)
  
}


### Normalize perturbability measures

normalize_perturbability <- function(perturbability_stats, windowRadius = 20){
  
  cellTypes = unique(perturbability_stats$cellType)
  
  normalized_perturbability_stats = list()
  for (cell in cellTypes) {
    
    cat(paste0("Working on ", cell, " data...\n"))
    genes = perturbability_stats$gene_id[perturbability_stats$cellType == cell]
    nGenes = length(unique(genes))
    
    n = 0
    for (gene in genes) {
      
      n = n+1
      
      entryOfGene = perturbability_stats %>% ungroup() %>%
        filter(cellType == cell, gene_id == gene)
      
      if(nrow(entryOfGene) > 1){
        cat(paste0("Error: gene_id ", gene, " in ", cell, " has ", as.character(nrow(entryOfGene)), " entries.\n"))
      }
      
      geneRank = entryOfGene$expRank
      
      normToNearbyEntries = perturbability_stats %>% ungroup() %>%
        filter(cellType == cell, expRank >= geneRank - windowRadius, expRank <= geneRank + windowRadius) %>%
        summarise(gene_id = gene,
                  cellType = cell,
                  nNearby = length(expRank),
                  normDeltaCV = sum(entryOfGene$deltaCV > deltaCV)/nNearby,
                  normDeltaKurtosis = sum(entryOfGene$deltaKurtosis > deltaKurtosis)/nNearby,
                  normDeltaSkewness = sum(entryOfGene$deltaSkewness > deltaSkewness)/nNearby,
                  normDeltaMM = sum(entryOfGene$deltaMM > deltaMM)/nNearby,
                  normDeltaPP = sum(entryOfGene$deltaPP > deltaPP)/nNearby,
                  norm_nDESeq2conditionsAll = sum(entryOfGene$nDESeq2conditionsAll > nDESeq2conditionsAll)/nNearby,
                  norm_nDESeq2conditionsUp = sum(entryOfGene$nDESeq2conditionsUp > nDESeq2conditionsUp)/nNearby,
                  norm_nDESeq2conditionsDown = sum(entryOfGene$nDESeq2conditionsDown > nDESeq2conditionsDown)/nNearby)
      
      fullEntry = inner_join(entryOfGene, normToNearbyEntries, by = c("cellType", "gene_id"))
      
      if(is.null(dim(normalized_perturbability_stats))) {
        normalized_perturbability_stats = fullEntry
      } else {
        normalized_perturbability_stats = bind_rows(normalized_perturbability_stats, fullEntry)
      }
      
      if(n %% round(nGenes/10) == 0){
        cat(paste0("Done with ", as.character(n), "/", as.character(nGenes), " genes\n"))
      }
      
    }
  }
  cat("Done with perturbability normalization.\n")
  return(normalized_perturbability_stats)
  
}


## Downsampling function for count matrix
# from https://stackoverflow.com/questions/37352980/downsample-matrix-in-r
# New function
downsample_counts <- function(mat, samplerate = 0.5) {
  new <- matrix(0, nrow(mat), ncol(mat))
  colnames(new) <- colnames(mat)
  rownames(new) <- rownames(mat)
  for (i in 1:nrow(mat)) {
    for (j in 1:ncol(mat)) {
      new[i,j] <- sum(runif(mat[i,j], 0, 1) < samplerate)
    }
  }
  return(new)
}


